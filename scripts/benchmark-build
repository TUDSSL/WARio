#!/bin/bash

# Build all the configured benchmarks for the provided project
# Expects the first argument to be the path to a project th

set -e

target="$1"
if [ -z "$1" ]; then
    target="all"
fi

CMAKE_TOOLCHAIN_FILE="$ICLANG_ROOT/toolchain-arm/toolchain.cmake"
function build_benchmark() {
    local benchmark_name="$1"
    local build_dir="build-$benchmark_name"
    echo "Building benchmark $benchmark_name in $build_dir"

    rm -rf "$build_dir"
    mkdir -p "$build_dir"
    pushd "$build_dir"

    cmake -DCMAKE_TOOLCHAIN_FILE="$CMAKE_TOOLCHAIN_FILE" ../
    make

    popd
}


#
# The base target configuration for intermittent computing
#

BASE_ICLANG_CODEGEN_FLAGS="\
-mllvm --idemp-force-lr-spill \
-mllvm --idemp-code-gen \
-mllvm --idemp-pop \
-mllvm --idemp-checkpoint-reason-markers"

EXTRA_ICLANG_CODEGEN_FLAGS="-mllvm --idemp-stack-spill-hitting-set"

#
# The different target configurations
#

# Uninstrumented
# Does not perform any transformations but does go trough the pipeline
function uninstrumented() {
    # Configure the benchmark
    export ICLANG_PASS_IDEMP_FLAGS=""
    export ICLANG_PASS_LOOP_UNROLL_FLAGS=""
    export ICLANG_PASS_LOOP_CLUSTER_FLAGS=""
    export ICLANG_PASS_WRITE_BUFFER_FLAGS=""

    export ICLANG_CODEGEN_FLAGS=""

    # Build the benchmark
    ICLANG_NO_PASSES="YES" build_benchmark "uninstrumented"
}

# Ratchet
# Uses Ratchet middle-end analysis ported to this version of LLVM
# The backend is different (our Thumb2) backend
function opt_ratchet() {
    # Configure the benchmark
    export ICLANG_PASS_IDEMP_FLAGS="-idemp -cp-ratchet"
    export ICLANG_PASS_LOOP_UNROLL_FLAGS=""
    export ICLANG_PASS_LOOP_CLUSTER_FLAGS=""
    export ICLANG_PASS_WRITE_BUFFER_FLAGS=""

    export ICLANG_CODEGEN_FLAGS="$BASE_ICLANG_CODEGEN_FLAGS"

    # Build the benchmark
    build_benchmark "opt-ratchet"
}

# Baseline
# Uses the Ratched way of finding checkpoint locations but improved to use
# Noelle information and to work with our other passes
function opt_baseline() {
    # Configure the benchmark
    export ICLANG_PASS_IDEMP_FLAGS="-idemp"
    export ICLANG_PASS_LOOP_UNROLL_FLAGS=""
    export ICLANG_PASS_LOOP_CLUSTER_FLAGS=""
    export ICLANG_PASS_WRITE_BUFFER_FLAGS=""

    export ICLANG_CODEGEN_FLAGS="$BASE_ICLANG_CODEGEN_FLAGS"

    # Build the benchmark
    build_benchmark "opt-baseline"
}

# Loop
# Uses the loop write clustering pass
function opt_loop() {
    # Configure the benchmark
    export ICLANG_PASS_IDEMP_FLAGS="-idemp"
    export ICLANG_PASS_LOOP_UNROLL_FLAGS="-loop-write-clusterer -lwc-loop-unroll -lwc-loop-unroll-count=8"
    export ICLANG_PASS_LOOP_CLUSTER_FLAGS="-loop-write-clusterer -lwc-loop-schedule"
    export ICLANG_PASS_WRITE_BUFFER_FLAGS=""

    export ICLANG_CODEGEN_FLAGS="$BASE_ICLANG_CODEGEN_FLAGS $EXTRA_ICLANG_CODEGEN_FLAGS"

    # Build the benchmark
    build_benchmark "opt-loop"

}

function opt_writebuf() {
    # Configure the benchmark
    export ICLANG_PASS_IDEMP_FLAGS="-idemp"
    export ICLANG_PASS_LOOP_UNROLL_FLAGS=""
    export ICLANG_PASS_LOOP_CLUSTER_FLAGS=""
    export ICLANG_PASS_WRITE_BUFFER_FLAGS="-write-buffer"

    export ICLANG_CODEGEN_FLAGS="$BASE_ICLANG_CODEGEN_FLAGS $EXTRA_ICLANG_CODEGEN_FLAGS"

    # Build the benchmark
    build_benchmark "opt-writebuf"
}

function opt_all() {
    # Configure the benchmark
    export ICLANG_PASS_IDEMP_FLAGS="-idemp"
    export ICLANG_PASS_LOOP_UNROLL_FLAGS="-loop-write-clusterer -lwc-loop-unroll -lwc-loop-unroll-count=8"
    export ICLANG_PASS_LOOP_CLUSTER_FLAGS="-loop-write-clusterer -lwc-loop-schedule"
    export ICLANG_PASS_WRITE_BUFFER_FLAGS="-write-buffer"

    export ICLANG_CODEGEN_FLAGS="$BASE_ICLANG_CODEGEN_FLAGS $EXTRA_ICLANG_CODEGEN_FLAGS"

    # Build the benchmark
    build_benchmark "opt-all"
}


function all() {
    uninstrumented
    opt_ratchet
    opt_baseline
    opt_loop
    opt_all
}

function all_parallel() {
    uninstrumented >/dev/null 2>&1 &
    opt_ratchet >/dev/null 2>&1 &
    opt_baseline >/dev/null 2>&1 &
    opt_all >/dev/null 2>&1 &
    wait
}

function clean() {
    echo "Removing build directories"
    # Don't use a wildcard, it might remove builds not generated here
    rm -rf "./build-uninstrumented"
    rm -rf "./build-opt-ratchet"
    rm -rf "./build-opt-baseline"
    rm -rf "./build-opt-loop"
    rm -rf "./build-opt-all"
}

function print_help() {
    echo "Usage: benchmark-build [target]"
    echo ""
    echo "targets:"
    echo "  all (default)"
    echo "  uninstrumented"
    echo "  opt-ratchet"
    echo "  opt-baseline"
    echo "  opt-loop"
    echo "  opt-writebuf"
    echo "  opt-all"
    echo "  all-parallel (build all the benchmarks in parallel)"
}

declare -A ConfigMap
ConfigMap["help"]=print_help
ConfigMap["-h"]=print_help
ConfigMap["--help"]=print_help
ConfigMap["clean"]=clean

ConfigMap["all"]=all
ConfigMap["all-parallel"]=all_parallel
ConfigMap["uninstrumented"]=uninstrumented
ConfigMap["opt-ratchet"]=opt_ratchet
ConfigMap["opt-baseline"]=opt_baseline
ConfigMap["opt-loop"]=opt_loop
ConfigMap["opt-writebuf"]=opt_writebuf
ConfigMap["opt-all"]=opt_all


if ! [[ ${ConfigMap[$target]+isset} ]]; then
    echo "Unknown target: $target"
    print_help
    exit -1
fi

# Build the target
${ConfigMap["$target"]}
