Goal:
- Identify WAR dependences in loops.
- "Clump" or "buffer" as many writes as possible in the 
  latch of the loop body. This way, we can break as many
  semantic WAR dependences as possible.

- Example:

  body:
    read
    write
    ...

  latch:
    br body
  

  INTO


  body:
    read
    ...
    read
    ...

    ...

  latch:
    write
    write
    br body


- This involves the following basic transformations:
  1) Unrolling loops in order to expose as many WAR dependences
     as possible in order to "clump"
  2) Schedule the identified writes into the latch of a loop


On #2:
- "Clumping" writes at the latch of the loop isn't as simple 
  as it sounds. We must write to the buffer such that we do
  not break the semantics of the control flow. For example, if
  the loop has several exits, the exiting basic block must also
  perform the write before leaving the loop body.
- If the WAR dependences are also loop-carried, scheduling is 
  a lot more tricky, and we will ignore those transformations 
  for now. More pedantic --- if the read depends on the previous
  iteration's write, then we cannot batch writes at the latch
  of the loop.

Another possible transformation to handle loop-carried dependences
blocking write-batching:
- If the compiler says an iteration's read (may) depend on the 
  previous iteration's write, we can play the following trick and
  still keep write-batching:
  1) For each read, inejct a dynamic check --- is the address we're
     reading from the same address we would have written to in the
     previous iteration.
  2) If this is the case, instead of performing the read, replace the
     value the instruction would have loaded with the value we would
     have written to in the previous write. Essentially, we are breaking
     a level of indirection that would've existed by storing a value
     to a memory location.


